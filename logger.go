/*
 Copyright 2016 Derrick J. Wippler. All rights reserved.
 Use of this source code is governed by a BSD-style
 license that can be found in the LICENSE file.

COPY NOTICE
wrapWriter() with associated code and struct's copied from CHI middleware
 at https://github.com/pressly/chi/blob/master/middleware/logger.go with modifications
*/

package detka

import (
	"io"
	"net"
	"net/http"
	"strconv"
	"time"

	"github.com/Sirupsen/logrus"
	"golang.org/x/net/context"

	"github.com/oxtoacart/bpool"
	"github.com/pressly/chi"
	"github.com/pressly/chi/middleware"
)

var bufferPool bpool.BufferPool

func Logger(next chi.Handler) chi.Handler {
	return chi.HandlerFunc(func(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
		buf := bufferPool.Get()

		// TODO: Parse X-Forward-Host if present

		// Add the client remote address
		remoteAddress, _, err := net.SplitHostPort(req.RemoteAddr)
		if err != nil {
			remoteAddress = req.RemoteAddr
		}

		buf.WriteString(remoteAddress)
		buf.WriteString(" - ")

		// Add the authenticated user (if none then '-')
		if req.URL.User != nil {
			if name := req.URL.User.Username(); name != "" {
				buf.WriteString(name)
			} else {
				buf.WriteString("-")
			}
		} else {
			buf.WriteString("-")
		}

		// Time
		buf.WriteString(" [")
		// TODO: Use AppendFormat to avoid allocated a new buffer on each Format() call
		buf.WriteString(time.Now().Format("01/Jan/2015:01:01:01 -0600"))
		buf.WriteString("] ")
		// Http Verb
		buf.WriteString(" ")
		buf.WriteString(req.Method)
		// Uri
		buf.WriteString(" ")
		buf.WriteString(req.URL.RequestURI())
		buf.WriteString(" ")
		// Proto
		buf.WriteString(req.Proto)
		buf.WriteString(" ")

		// Wrap the ResponseWriter so we can capture the Status() and BytesWritten()
		wrapResp := wrapWriter(resp)

		// Run the handler
		startTime := time.Now()
		next.ServeHTTPC(ctx, wrapResp, req)
		stopTime := time.Now()

		// Time Elapsed
		elapsed := stopTime.Sub(startTime)
		buf.WriteString(elapsed.String())
		buf.WriteString(" ")

		// Status and Payload Size
		status := wrapResp.Status()
		if status == middleware.StatusClientClosedRequest {
			buf.WriteString("[disconnected]")
		} else {
			// Status Code
			buf.WriteString(strconv.Itoa(status))
			buf.WriteString(" ")
			// Result Size
			buf.WriteString(strconv.Itoa(wrapResp.BytesWritten()))
		}

		// Write out the log entry
		logrus.Info(buf)
		// Put the buffer back into the pool
		bufferPool.Put(buf)
	})
}

// writerProxy is a proxy around an http.ResponseWriter that allows you to hook
// into various parts of the response process.
type writerProxy interface {
	http.ResponseWriter
	// Status returns the HTTP status of the request, or 0 if one has not
	// yet been sent.
	Status() int
	// BytesWritten returns the total number of bytes sent to the client.
	BytesWritten() int
	// Tee causes the response body to be written to the given io.Writer in
	// addition to proxying the writes through. Only one io.Writer can be
	// tee'd to at once: setting a second one will overwrite the first.
	// Writes will be sent to the proxy before being written to this
	// io.Writer. It is illegal for the tee'd writer to be modified
	// concurrently with writes.
	Tee(io.Writer)
	// Unwrap returns the original proxied target.
	Unwrap() http.ResponseWriter
}

// WrapWriter wraps an http.ResponseWriter, returning a proxy that allows you to
// hook into various parts of the response process.
func wrapWriter(resp http.ResponseWriter) writerProxy {
	closeNotifier := resp.(http.CloseNotifier)
	flusher := resp.(http.Flusher)
	hiJacker := resp.(http.Hijacker)
	readerFrom := resp.(io.ReaderFrom)

	return &WrappedWriter{
		ReaderFrom:     readerFrom,
		Hijacker:       hiJacker,
		Flusher:        flusher,
		CloseNotifier:  closeNotifier,
		ResponseWriter: resp}
}

// Wraps a http.ResponseWriter includes all possible interfaces
type WrappedWriter struct {
	io.ReaderFrom
	http.Hijacker
	http.Flusher
	http.CloseNotifier
	http.ResponseWriter
	wroteHeader bool
	code        int
	bytes       int
	tee         io.Writer
}

func (self *WrappedWriter) WriteHeader(code int) {
	if !self.wroteHeader {
		self.code = code
		self.wroteHeader = true
		self.ResponseWriter.WriteHeader(code)
	}
}
func (self *WrappedWriter) Write(buf []byte) (int, error) {
	self.WriteHeader(http.StatusOK)
	n, err := self.ResponseWriter.Write(buf)
	if self.tee != nil {
		_, err2 := self.tee.Write(buf[:n])
		// Prefer errors generated by the proxied writer.
		if err == nil {
			err = err2
		}
	}
	self.bytes += n
	return n, err
}
func (self *WrappedWriter) maybeWriteHeader() {
	if !self.wroteHeader {
		self.WriteHeader(http.StatusOK)
	}
}
func (self *WrappedWriter) Status() int {
	return self.code
}
func (self *WrappedWriter) BytesWritten() int {
	return self.bytes
}
func (self *WrappedWriter) Tee(writer io.Writer) {
	self.tee = writer
}
func (self *WrappedWriter) Unwrap() http.ResponseWriter {
	return self.ResponseWriter
}

var _ http.CloseNotifier = &WrappedWriter{}
var _ http.Flusher = &WrappedWriter{}
var _ http.Hijacker = &WrappedWriter{}
var _ io.ReaderFrom = &WrappedWriter{}
var _ http.Flusher = &WrappedWriter{}
